import random
from typing import Optional
from Gym.environment import VerifiableEnvironment
from collections import deque


class CardColoringCounting_Environment(VerifiableEnvironment) : # Source : https://www.luogu.com.cn/problem/P1446
    prompt_template = \
r"""You have **{N}** cards, and there are some card shuffling methods. Each shuffle method is described by a row of {N} integers: X_1, X_2, ..., X_{N}. After applying a shuffle method, the card at position i moves to the position X_i. The shuffling methods are as follows:
{shuffling_methods}

Now, you need to color these cards into **{R}** red cards, **{G}** green cards, and **{B}** blue cards.
Determine how many distinct coloring schemes exist, where two colorings are considered the same if and only if one can be transformed into the other by any combination of the available shuffling methods (shuffles may be applied multiple times and in any order).

**Output Format:** Your final answer should be a single integer â€” the total number of distinct coloring schemes, considering equivalence under the shuffling methods."""

    def __init__(self,
                 wrong_format : float = -1.0, rewarding_strategy : str = "(min/max)^beta", rewarding_weight : float = 1.0, rewarding_beta : float = 10.0,
                 **kwargs) :
        """
        Initialize the CardColoringCounting_Environment instance.
        """
        super().__init__(**kwargs)

        self.rewards = {
            "wrong_format" : wrong_format,
            "rewarding_strategy" : rewarding_strategy,
            "rewarding_weight" : rewarding_weight,
            "rewarding_beta" : rewarding_beta,
        }
    
    def _generate(self) -> None :
        assert "N" in self.parameter, "N is required in parameter"
        N = self.parameter["N"]
        assert N >= 2, "N should be greater than or equal to 2"

        assert "K" in self.parameter, "K is required in parameter"
        K = self.parameter["K"]
        assert K >= 0, "K should be greater than or equal to 0"

        # Randomly generate R, G, B such that R + G + B = N
        R = random.randint(0, N)
        remaining = N - R
        G = random.randint(0, remaining)
        B = remaining - G
        RGB = [R, G, B]
        random.shuffle(RGB)
        R, G, B = RGB
        self.parameter["R"] = R
        self.parameter["G"] = G
        self.parameter["B"] = B

        # Randomly select K permutations from all N-permutations
        # For large N, generating all permutations is infeasible.
        # Instead, generate K random shuffling methods (permutations) directly.
        selected_perms = []
        while len(selected_perms) < K:
            perm = tuple(random.sample(range(1, N + 1), N))
            selected_perms.append(perm)

        self.parameter["shuffling_methods"] = selected_perms

        # Generate the subgroup generated by selected_perms

        def perm_compose(p1, p2):
            # Compose two permutations (1-based indexing)
            return tuple(p1[p2[i]-1] for i in range(len(p1)))

        # Start with the identity permutation
        identity = tuple(range(1, N+1))
        subgroup = set()
        queue = deque()
        subgroup.add(identity)
        queue.append(identity)

        for perm in selected_perms:
            perm_tuple = tuple(perm)
            if perm_tuple not in subgroup:
                subgroup.add(perm_tuple)
                queue.append(perm_tuple)

        while queue:
            current = queue.popleft()
            for perm in selected_perms:
                perm_tuple = tuple(perm)
                composed = perm_compose(current, perm_tuple)
                if composed not in subgroup:
                    subgroup.add(composed)
                    queue.append(composed)

        subgroup_perms = [list(perm) for perm in subgroup]

        def solve(n: int, red: int, blue: int, green: int, v: list) -> int:
            # Initialize visited array for cycle detection
            vis = [False] * (n + 1)
            
            # dp table dimensions dynamically based on R, G, B counts
            # dp[r][b][g] stores the number of ways to arrange r red, b blue, g green items
            dp = [[[0 for _ in range(green + 1)] for _ in range(blue + 1)] for _ in range(red + 1)]
            
            num_cycles = 0
            cycle_sizes = [0] * (n+1) # Stores the length of each cycle found

            # Step 1: Detect cycles in the permutation
            for i in range(1, n + 1):
                if not vis[i]:
                    x = i
                    len_cycle = 0
                    while not vis[x]:
                        len_cycle += 1
                        vis[x] = True
                        x = v[x] # Follow the permutation cycle
                    num_cycles += 1
                    cycle_sizes[num_cycles] = len_cycle

            # Step 2: Initialize DP for no items
            dp[0][0][0] = 1

            # Step 3: Populate DP table using cycle lengths
            # Iterate through each detected cycle
            for x_idx in range(1, num_cycles + 1):
                current_size = cycle_sizes[x_idx]
                # Iterate backwards through the DP table to use previous states
                for i in range(red, -1, -1):
                    for j in range(blue, -1, -1):
                        for k in range(green, -1, -1):
                            # If current cycle size can be used for red items
                            if i >= current_size:
                                dp[i][j][k] += dp[i - current_size][j][k]
                            # If current cycle size can be used for blue items
                            if j >= current_size:
                                dp[i][j][k] += dp[i][j - current_size][k]
                            # If current cycle size can be used for green items
                            if k >= current_size:
                                dp[i][j][k] += dp[i][j][k - current_size]
            
            return dp[red][blue][green]

        def work(N: int, R: int, G: int, B: int, subgroup_perms: list[list[int]]) -> int:
            total_ans = 0
            num_of_perms = len(subgroup_perms)
            for perm_list in subgroup_perms:
                # Create a 1-indexed permutation list 'v_current' from the input 'perm_list'
                v_current = [0] * (N + 1)
                for idx in range(N):
                    v_current[idx + 1] = perm_list[idx] # Adjusting for 1-based indexing
                
                total_ans += solve(N, R, B, G, v_current)

            # Only add the identity permutation if it is not already in subgroup_perms
            v_identity = [i for i in range(1, N + 1)]
            if v_identity not in subgroup_perms:
                num_of_perms += 1
                v_identity_full = [0] + v_identity  # 1-based indexing
                total_ans += solve(N, R, B, G, v_identity_full)
            
            return total_ans // num_of_perms

        self.parameter["reference_answer"] = work(N, R, G, B, subgroup_perms)
        assert self.parameter["reference_answer"] > 0
    

    def _prompt_generate(self) -> str :
        return self.prompt_template.format(
            N = self.parameter["N"],
            R = self.parameter["R"],
            G = self.parameter["G"],
            B = self.parameter["B"],
            shuffling_methods = "\n".join(" ".join(map(str, perm)) for perm in self.parameter["shuffling_methods"]),
        )
    

    def _process(self, answer : Optional[str]) -> Optional[int] :
        if answer is not None :
            answer = answer.strip()
            try :
                int_answer = int(answer)
                return int_answer
            except ValueError :
                return None
        else :
            return None

    def scorer(self, output : str) -> float :
        processed_result = self.processor(output)
        if processed_result is not None :
            if processed_result <= 0 :
                return self.rewards["wrong_format"]

            if self.rewards["rewarding_strategy"] == "(min/max)^beta" :
                a, b = self.parameter["reference_answer"], processed_result
                return self.rewards["rewarding_weight"] * (((min(a, b) / max(a, b))) ** self.rewards["rewarding_beta"])
            elif self.rewards["rewarding_strategy"] == "gold=answer" :
                return self.rewards["rewarding_weight"] * (processed_result == self.parameter["reference_answer"])
            else :
                raise NotImplementedError("Unknown rewarding strategy: {}".format(self.rewards["rewarding_strategy"]))
        else :
            return self.rewards["wrong_format"]